import{_ as n}from"./plugin-vue_export-helper-DlAUqK2U.js";import{c as o,a as s,o as r}from"./app-BTyvM1qB.js";const e={};function d(a,t){return r(),o("div",null,t[0]||(t[0]=[s(`<h4 id="_1-rag的数据结构设计-为精准检索奠定基石" tabindex="-1"><a class="header-anchor" href="#_1-rag的数据结构设计-为精准检索奠定基石"><span><strong>1. RAG的数据结构设计：为精准检索奠定基石</strong></span></a></h4><p>构建一个健壮的RAG系统的第一步，是设计一个优秀的、信息丰富的<strong>数据结构</strong>。我们存入向量数据库的，不应该仅仅是“文本块+向量”，而是一个结构化的**“数据节点（Node/Chunk）”**。</p><p><strong>一个理想的数据节点Schema应包含：</strong></p><table><thead><tr><th>字段名</th><th>类型</th><th>描述</th><th>示例</th></tr></thead><tbody><tr><td><code>chunk_id</code></td><td>String (UUID)</td><td><strong>唯一的块ID</strong>。用于精确引用和更新。</td><td><code>“c1a2b3d4-…”</code></td></tr><tr><td><code>content</code></td><td>String</td><td><strong>文本块原文</strong>。这是将要被Embedding和提供给LLM的核心内容。</td><td><code>“RAG的核心是检索...”</code></td></tr><tr><td><code>vector</code></td><td>Array[Float]</td><td><strong>文本块的向量表示</strong>。由Embedding模型生成。</td><td><code>[0.12, -0.45, ...]</code></td></tr><tr><td><code>metadata</code></td><td>Object/JSON</td><td><strong>丰富的元数据</strong>。这是实现高级功能的关键，必须精心设计。</td><td>(见下方详细示例)</td></tr></tbody></table><p><code>**metadata**</code>** 示例：**</p><div class="language-plain line-numbers-mode" data-highlighter="shiki" data-ext="plain" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code class="language-plain"><span class="line"><span>{</span></span>
<span class="line"><span>  &quot;source_type&quot;: &quot;PDF&quot;,</span></span>
<span class="line"><span>  &quot;source_id&quot;: &quot;doc_xyz_123&quot;, // 原始文档的唯一ID</span></span>
<span class="line"><span>  &quot;document_title&quot;: &quot;初始阶段第一次治疗话术.pdf&quot;,</span></span>
<span class="line"><span>  &quot;page_number&quot;: 42,</span></span>
<span class="line"><span>  &quot;chunk_sequence_in_doc&quot;: 105, // 这是该文档中的第105个块</span></span>
<span class="line"><span>  &quot;author&quot;: &quot;xxx&quot;,</span></span>
<span class="line"><span>  &quot;creation_date&quot;: &quot;2025-04-15&quot;,</span></span>
<span class="line"><span>  &quot;security_level&quot;: &quot;CONFIDENTIAL&quot;,</span></span>
<span class="line"><span>  &quot;tags&quot;: [&quot;finance&quot;, &quot;quarterly_report&quot;, &quot;Q1&quot;],</span></span>
<span class="line"><span>  &quot;keywords&quot;: [&quot;求治原因&quot;, &quot;人际关系圈&quot;, &quot;抑郁症&quot;] // 可选，通过LLM提取</span></span>
<span class="line"><span>}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><strong>为什么这个结构很重要？</strong></p><ul><li><strong>精准过滤</strong>：您可以在向量搜索前或搜索后，根据元数据进行过滤（例如，<code>source_type == &#39;PDF&#39; AND page_number &gt; 10</code>），极大地缩小检索范围，提升精准度。</li><li><strong>可溯源性</strong>：当LLM根据某个Chunk生成答案时，您可以利用元数据（如文件名、页码）向用户展示<strong>答案的来源</strong>，增强应用的可信度。</li><li><strong>可维护性</strong>：当原始文档更新时，可以通过<code>source_id</code>快速找到并更新或删除所有相关的Chunks。</li></ul><h4 id="_2-rag的评测与埋点-衡量系统的-好-与-坏" tabindex="-1"><a class="header-anchor" href="#_2-rag的评测与埋点-衡量系统的-好-与-坏"><span><strong>2. RAG的评测与埋点：衡量系统的“好”与“坏”</strong></span></a></h4><p>“埋点”是为了收集数据，而数据是为了评测。一个没有评测体系的RAG系统，其优化过程如同“闭门造车”。</p><p><strong>A. 离线评测（上线前）</strong> 在开发阶段，我们需要一套“黄金评估集”来衡量RAG系统的核心组件——**检索器（Retriever）**的性能。</p><ul><li><strong>核心评测指标</strong>： <ul><li><strong>命中率 (Hit Rate)</strong>：对于一个问题，我们期望的答案是否出现在了召回的Top-K个文档中？</li><li><strong>平均倒数排名 (Mean Reciprocal Rank, MRR)</strong>：衡量的是我们找到的第一个相关文档的排名的倒数。这个指标越接近1，说明系统能越快地找到正确答案。</li><li><strong>归一化折损累计增益 (nDCG)</strong>：一个更复杂的指标，它不仅考虑是否命中，还考虑了相关文档的排名位置，排名越靠前得分越高。</li></ul></li></ul><p><strong>B. 在线评测（上线后，即“埋点”）</strong> 当系统上线后，我们需要通过埋点来收集真实的用户行为和系统数据，以进行持续的迭代。</p><ul><li><strong>需要埋点记录的核心数据</strong>： <ul><li><strong>用户输入</strong>：<code>query</code> (用户的问题)</li><li><strong>检索结果</strong>：<code>retrieved_chunks</code> (召回的文本块原文、ID和相关性分数)</li><li><strong>生成结果</strong>：<code>generated_answer</code> (LLM最终生成的答案)</li><li><strong>用户反馈</strong>： <ul><li><strong>显式反馈</strong>：**“顶/踩”<strong>按钮、</strong>“答案是否有用？”<strong>的评分、用户主动提交的</strong>“复制答案”**事件。</li><li><strong>隐式反馈</strong>：用户是否在得到答案后继续追问、是否修改了问题重新搜索。</li></ul></li><li><strong>系统性能</strong>：<code>retrieval_latency</code> (检索耗时), <code>generation_latency</code> (生成耗时)。</li></ul></li></ul><p>通过分析这些埋点数据，可以回答诸如“哪些类型的问题检索效果不好？”、“用户对哪些答案不满意？”等关键问题，从而找到迭代的方向。</p><h4 id="_3-rag的核心策略与方法选择" tabindex="-1"><a class="header-anchor" href="#_3-rag的核心策略与方法选择"><span><strong>3. RAG的核心策略与方法选择</strong></span></a></h4><p>一个基础的RAG流程（切块-&gt;编码-&gt;检索-&gt;生成）只是起点。要打造SOTA级别的系统，需要采用更高级的策略。</p><table><thead><tr><th>策略类别</th><th>具体方法</th><th>解决什么问题</th><th>何时选择</th></tr></thead><tbody><tr><td><strong>基础RAG (Naive RAG)</strong></td><td>简单的“检索-生成”</td><td>快速搭建原型，验证基本流程。</td><td><strong>项目启动时</strong>，作为性能基线（Baseline）。</td></tr><tr><td><strong>高级检索 (Advanced Retrieval)</strong></td><td><strong>1. 混合搜索 (Hybrid Search)</strong> <strong>2. 重排序 (Re-ranking)</strong></td><td>1. 召回不足，语义和关键词都想要。 2. 召回结果多但不够精准，“噪音”太多。</td><td>1. 当用户问题中包含大量<strong>专有名词、ID、代码</strong>时。 2. 当对检索的**精准度（Precision）有极高要求时。</td></tr><tr><td>高级索引 (Advanced Indexing)</td><td>1. 父文档检索器 (Parent Document Retriever) 2. 多表示索引 (Multi-Representation Indexing)</td><td>1. 检索到的上下文太短，LLM理解不全面。 2. 用户问题角度多变，单一向量无法覆盖。</td><td>1. 当需要为LLM提供更完整上下文<strong>时。 ****2. 当文档包含</strong>摘要、标题、表格**等多种形式的内容时。</td></tr><tr><td><strong>高级生成 (Advanced Generation)</strong></td><td><strong>1. 查询转换 (Query Transformation)</strong> <strong>2. 上下文压缩 (Contextual Compression)</strong></td><td>1. 用户问题模糊、不规范，直接检索效果差。 2. 召回的上下文太长或有冗余，超出LLM窗口或增加成本。</td><td>1. 当发现大量用户查询是<strong>口语化或不完整</strong>的。 2. 当需要<strong>极致优化Token成本</strong>或处理长文档时。</td></tr></tbody></table><p><strong>决策流程建议</strong>：</p><ol><li><strong>从基础RAG开始</strong>，并建立好评测和埋点体系。</li><li>分析评测结果和线上数据，<strong>定位瓶颈</strong>。</li><li><strong>如果检索结果不精准</strong> -&gt; 优先引入 <strong>Re-ranking</strong>。</li><li><strong>如果检索结果经常“漏掉”正确答案</strong> -&gt; 尝试 <strong>Hybrid Search</strong>。</li><li><strong>如果检索到的上下文信息不足</strong> -&gt; 尝试 <strong>Parent Document Retriever</strong>。</li><li><strong>如果用户问题质量不高</strong> -&gt; 尝试 <strong>Query Transformation</strong>。</li></ol><p><strong>总结</strong>：构建一个生产级的RAG系统，是一个从<strong>数据结构设计</strong>出发，以<strong>评测与埋点</strong>为罗盘，通过不断实验和迭代，逐步叠加<strong>高级策略</strong>的系统工程。清晰的数据结构是基础，科学的评测体系是导航，而丰富的策略库则是达成目标的工具箱。</p>`,21)]))}const l=n(e,[["render",d]]),c=JSON.parse('{"path":"/tech/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%B1%87%E6%80%BB/rag.html","title":"rag","lang":"zh-CN","frontmatter":{"title":"rag","date":"2025-06-28T00:00:00.000Z"},"git":{"createdTime":1753758135000,"updatedTime":1753843586000,"contributors":[{"name":"codingXuan","username":"codingXuan","email":"34129858+codingXuan@users.noreply.github.com","commits":3,"url":"https://github.com/codingXuan"}]},"readingTime":{"minutes":4.95,"words":1484},"filePathRelative":"tech/数据结构汇总/rag.md","excerpt":"<h4><strong>1. RAG的数据结构设计：为精准检索奠定基石</strong></h4>\\n<p>构建一个健壮的RAG系统的第一步，是设计一个优秀的、信息丰富的<strong>数据结构</strong>。我们存入向量数据库的，不应该仅仅是“文本块+向量”，而是一个结构化的**“数据节点（Node/Chunk）”**。</p>\\n<p><strong>一个理想的数据节点Schema应包含：</strong></p>\\n<table>\\n<thead>\\n<tr>\\n<th>字段名</th>\\n<th>类型</th>\\n<th>描述</th>\\n<th>示例</th>\\n</tr>\\n</thead>\\n<tbody>\\n<tr>\\n<td><code>chunk_id</code></td>\\n<td>String (UUID)</td>\\n<td><strong>唯一的块ID</strong>。用于精确引用和更新。</td>\\n<td><code>“c1a2b3d4-…”</code></td>\\n</tr>\\n<tr>\\n<td><code>content</code></td>\\n<td>String</td>\\n<td><strong>文本块原文</strong>。这是将要被Embedding和提供给LLM的核心内容。</td>\\n<td><code>“RAG的核心是检索...”</code></td>\\n</tr>\\n<tr>\\n<td><code>vector</code></td>\\n<td>Array[Float]</td>\\n<td><strong>文本块的向量表示</strong>。由Embedding模型生成。</td>\\n<td><code>[0.12, -0.45, ...]</code></td>\\n</tr>\\n<tr>\\n<td><code>metadata</code></td>\\n<td>Object/JSON</td>\\n<td><strong>丰富的元数据</strong>。这是实现高级功能的关键，必须精心设计。</td>\\n<td>(见下方详细示例)</td>\\n</tr>\\n</tbody>\\n</table>"}');export{l as comp,c as data};
