import{_ as n}from"./plugin-vue_export-helper-DlAUqK2U.js";import{c as a,b as i,o as e}from"./app-7M4PPNja.js";const l={};function t(p,s){return e(),a("div",null,s[0]||(s[0]=[i(`<h4 id="_1-核心定位-向量检索的-高性能计算引擎" tabindex="-1"><a class="header-anchor" href="#_1-核心定位-向量检索的-高性能计算引擎"><span><strong>1. 核心定位：向量检索的“高性能计算引擎”</strong></span></a></h4><p>Faiss (Facebook AI Similarity Search) 是由 <strong>Facebook AI Research（现Meta AI）开发的、一个专注于高性能向量相似度搜索</strong>的<strong>开源库（Library）</strong>。</p><p>最核心的认知是：<strong>Faiss不是一个数据库，而是一个算法库。</strong></p><p>我们可以用一个比喻来理解它和向量数据库的关系：</p><ul><li><strong>Faiss</strong>：如同汽车里那台经过极致性能优化的**“V12发动机”**。它的唯一职责就是以最快的速度进行核心计算（向量相似度搜索），它本身不带轮子、方向盘或车身。</li><li><strong>ChromaDB / Milvus</strong>：则是一辆**“完整的汽车”**。这辆汽车的心脏可能就是一台类似Faiss的发动机，但它还提供了方向盘（API接口）、车身（数据管理）、油箱（持久化存储）、轮胎（网络服务）等所有部件，让可以直接“驾驶”。</li></ul><h4 id="_2-库-vs-数据库-一个关键的区别" tabindex="-1"><a class="header-anchor" href="#_2-库-vs-数据库-一个关键的区别"><span><strong>2. “库” vs. “数据库”：一个关键的区别</strong></span></a></h4><table><thead><tr><th>特性</th><th><strong>Faiss (库 / Library)</strong></th><th><strong>ChromaDB / Milvus (数据库 / Database)</strong></th></tr></thead><tbody><tr><td><strong>核心职责</strong></td><td>提供<strong>在内存中</strong>进行高效向量搜索的算法实现。</td><td>提供一个<strong>完整的、可独立运行的服务</strong>，用于管理、存储、检索数据。</td></tr><tr><td><strong>数据管理</strong></td><td><strong>不负责</strong>。需要自己管理原始文本、元数据，并维护ID和向量之间的映射关系。</td><td><strong>负责</strong>。内置了数据管理系统，支持向量、文本和元数据的增删改查（CRUD）。</td></tr><tr><td><strong>持久化</strong></td><td><strong>不自动处理</strong>。它是一个纯内存的工具，需要自己手动将构建好的索引（Index）序列化并保存到磁盘文件中，下次使用时再手动加载。</td><td><strong>自动处理</strong>。拥有自己的存储引擎，数据写入后会自动持久化到磁盘，保证了数据的可靠性。</td></tr><tr><td><strong>服务模式</strong></td><td><strong>嵌入式</strong>。它作为Python程序的一部分被直接调用。</td><td><strong>客户端-服务器模式</strong>。它作为一个独立的服务运行，的应用通过网络API来访问它。</td></tr><tr><td><strong>功能范畴</strong></td><td><strong>专注</strong>于向量的ANN（近似最近邻）搜索算法。</td><td><strong>全面</strong>，除了向量搜索，还提供过滤、混合搜索、扩缩容、权限管理等。</td></tr></tbody></table><p><strong>结论</strong>：不能像连接MySQL一样去“连接”Faiss。是在的代码中 <code>import faiss</code>，然后像使用一个工具函数一样去调用它的功能。</p><h4 id="_3-faiss是如何工作的-核心概念" tabindex="-1"><a class="header-anchor" href="#_3-faiss是如何工作的-核心概念"><span><strong>3. Faiss是如何工作的？核心概念</strong></span></a></h4><p>Faiss的强大之处在于它提供了极其丰富的索引（Index）类型，让开发者可以在<strong>搜索速度、内存占用和搜索精度</strong>这三者之间做出精细的权衡。</p><ul><li><code>**Index**</code>** 对象**：这是Faiss的核心。可以把它想象成一个专门为向量搜索优化过的数据结构。将向量“添加”到这个Index中，然后就可以用它来进行高效的搜索。</li><li><strong>几种关键的索引类型</strong>： <ol><li><code>**IndexFlatL2**</code>** (精确索引)** <ul><li><strong>原理</strong>：暴力搜索。它会计算查询向量与索引中每一个向量之间的真实距离，然后返回最接近的几个。</li><li><strong>特点</strong>：结果100%准确，但当数据量巨大时，搜索速度会非常慢。适合作为评估其他索引精度的“黄金标准”。</li></ul></li><li><code>**IndexIVFFlat**</code>** (倒排文件索引)** <ul><li><strong>原理</strong>：这是最经典的近似搜索算法之一。它会先将整个向量空间通过聚类（如k-means）划分成若干个“区域”（Cells）。搜索时，它会先定位到查询向量所在的几个邻近区域，然后只在这几个小区域内进行暴力搜索。</li><li><strong>特点</strong>：通过缩小搜索范围，极大地提升了搜索速度。它需要在添加向量之前，先用一部分代表性数据对索引进行**“训练（train）”**，以完成空间的划分。</li></ul></li><li><code>**IndexHNSWFlat**</code>** (图索引)** <ul><li><strong>原理</strong>：基于“六度空间”理论，通过构建一个多层的、导航式的图结构来连接所有向量。搜索时，从一个粗糙的顶层图开始，像导航一样，一步步跳跃到越来越精确的图层，最终在底层图中找到最近的邻居。</li><li><strong>特点</strong>：这是当前性能最好、应用最广的近似搜索算法之一，在速度和精度的平衡上做得非常出色。</li></ul></li></ol></li></ul><h4 id="_4-faiss的典型工作流-python示例" tabindex="-1"><a class="header-anchor" href="#_4-faiss的典型工作流-python示例"><span><strong>4. Faiss的典型工作流（Python示例）</strong></span></a></h4><p>Python</p><div class="language-plain line-numbers-mode" data-highlighter="shiki" data-ext="plain" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code class="language-plain"><span class="line"><span>import numpy as np</span></span>
<span class="line"><span>import faiss</span></span>
<span class="line"><span></span></span>
<span class="line"><span># 0. 准备数据</span></span>
<span class="line"><span>d = 64      # 向量维度</span></span>
<span class="line"><span>nb = 100000 # 数据集大小</span></span>
<span class="line"><span>nq = 10000  # 查询向量数量</span></span>
<span class="line"><span></span></span>
<span class="line"><span># 创建一些随机的向量数据</span></span>
<span class="line"><span>np.random.seed(1234)</span></span>
<span class="line"><span>xb = np.random.random((nb, d)).astype(&#39;float32&#39;)</span></span>
<span class="line"><span>xq = np.random.random((nq, d)).astype(&#39;float32&#39;)</span></span>
<span class="line"><span></span></span>
<span class="line"><span></span></span>
<span class="line"><span># 1. 选择并构建索引 (以IndexIVFFlat为例)</span></span>
<span class="line"><span>nlist = 100  # 我们将空间划分为100个区域</span></span>
<span class="line"><span>quantizer = faiss.IndexFlatL2(d)  # 使用一个基础的精确索引来定义区域</span></span>
<span class="line"><span>index = faiss.IndexIVFFlat(quantizer, d, nlist)</span></span>
<span class="line"><span></span></span>
<span class="line"><span></span></span>
<span class="line"><span># 2. 训练索引 (Training) - 只有部分索引类型需要这一步</span></span>
<span class="line"><span># Faiss需要学习数据的分布，以完成空间划分</span></span>
<span class="line"><span>print(&quot;Is index trained?&quot;, index.is_trained) # False</span></span>
<span class="line"><span>index.train(xb)</span></span>
<span class="line"><span>print(&quot;Is index trained?&quot;, index.is_trained) # True</span></span>
<span class="line"><span></span></span>
<span class="line"><span></span></span>
<span class="line"><span># 3. 添加向量到索引 (Adding)</span></span>
<span class="line"><span>index.add(xb)</span></span>
<span class="line"><span>print(&quot;Total vectors in index:&quot;, index.ntotal) # 100000</span></span>
<span class="line"><span></span></span>
<span class="line"><span></span></span>
<span class="line"><span># 4. 执行搜索 (Searching)</span></span>
<span class="line"><span>k = 4  # 我们想为每个查询向量找到4个最近邻</span></span>
<span class="line"><span>D, I = index.search(xq, k)  # D是距离，I是索引ID</span></span>
<span class="line"><span></span></span>
<span class="line"><span>print(&quot;Search results shape:&quot;, I.shape) # (10000, 4)</span></span>
<span class="line"><span>print(&quot;First 5 results:\\n&quot;, I[:5])</span></span>
<span class="line"><span></span></span>
<span class="line"><span></span></span>
<span class="line"><span># 5. 手动持久化 (Saving and Loading)</span></span>
<span class="line"><span># Faiss不自动保存，需要手动将内存中的索引写入文件</span></span>
<span class="line"><span>faiss.write_index(index, &quot;my_index.faiss&quot;)</span></span>
<span class="line"><span></span></span>
<span class="line"><span># 下次使用时，可以从文件加载</span></span>
<span class="line"><span>index_loaded = faiss.read_index(&quot;my_index.faiss&quot;)</span></span>
<span class="line"><span>print(&quot;Loaded index has total vectors:&quot;, index_loaded.ntotal)</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><strong>总结</strong>：Faiss是向量检索领域一个无与伦比的、专注于性能的<strong>底层计算库</strong>。它为上层应用（包括许多向量数据库）提供了核心的ANN搜索能力。当需要在一个已经定义好的向量集合上，进行极致的、内存内的相似度搜索时，Faiss是的不二之选。而当需要一个完整的、包含数据管理和服务的解决方案时，就应该选择像ChromaDB或Milvus这样的<strong>向量数据库</strong>。</p>`,15)]))}const o=n(l,[["render",t]]),c=JSON.parse('{"path":"/AIGC%E6%A1%86%E6%9E%B6%E8%AF%A6%E8%A7%A3/RAG%E6%A0%B8%E5%BF%83%E7%BB%84%E4%BB%B6/%E5%90%91%E9%87%8F%E6%95%B0%E6%8D%AE%E5%BA%93/faiss%E5%BA%93.html","title":"faiss库","lang":"zh-CN","frontmatter":{"title":"faiss库"},"git":{"createdTime":1753758135000,"updatedTime":1753758135000,"contributors":[{"name":"codingXuan","username":"codingXuan","email":"34129858+codingXuan@users.noreply.github.com","commits":1,"url":"https://github.com/codingXuan"}]},"readingTime":{"minutes":5.07,"words":1521},"filePathRelative":"AIGC框架详解/RAG核心组件/向量数据库/faiss库.md","excerpt":"<h4><strong>1. 核心定位：向量检索的“高性能计算引擎”</strong></h4>\\n<p>Faiss (Facebook AI Similarity Search) 是由 <strong>Facebook AI Research（现Meta AI）开发的、一个专注于高性能向量相似度搜索</strong>的<strong>开源库（Library）</strong>。</p>\\n<p>最核心的认知是：<strong>Faiss不是一个数据库，而是一个算法库。</strong></p>\\n<p>我们可以用一个比喻来理解它和向量数据库的关系：</p>\\n<ul>\\n<li><strong>Faiss</strong>：如同汽车里那台经过极致性能优化的**“V12发动机”**。它的唯一职责就是以最快的速度进行核心计算（向量相似度搜索），它本身不带轮子、方向盘或车身。</li>\\n<li><strong>ChromaDB / Milvus</strong>：则是一辆**“完整的汽车”**。这辆汽车的心脏可能就是一台类似Faiss的发动机，但它还提供了方向盘（API接口）、车身（数据管理）、油箱（持久化存储）、轮胎（网络服务）等所有部件，让可以直接“驾驶”。</li>\\n</ul>"}');export{o as comp,c as data};
