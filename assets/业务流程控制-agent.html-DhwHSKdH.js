import{_ as n}from"./plugin-vue_export-helper-DlAUqK2U.js";import{c as o,a as g,o as e}from"./app-DqBjIU18.js";const r={};function l(i,t){return e(),o("div",null,t[0]||(t[0]=[g("<p><strong>1. 核心思想：从语言生成到任务执行</strong></p><p>传统的LLM应用以“问-答”为主，而Agent化的应用则将LLM从一个“语言模型”升级为了一个“任务执行大脑”。其核心思想是：利用LLM强大的自然语言理解和推理能力，将其作为中心控制器，通过生成结构化的指令来调用外部工具（API、数据库、代码等），从而完成复杂的、多步骤的业务流程。</p><p><strong>2. 单个Agent的内部构造 (The Anatomy of an Agent)</strong></p><p>一个功能完备的Agent，是“思考”与“行动”的结合体，其内部通常包含三大核心组件：</p><ul><li><strong>规划器 (Planner)</strong>：Agent的大脑，由LLM担当。它负责： <ul><li><strong>任务理解与拆解</strong>：将用户的模糊指令拆解成一系列清晰、可执行的步骤。</li><li><strong>工具选择</strong>：根据当前步骤，从一系列可用工具中选择最合适的一个。</li><li><strong>推理与决策</strong>：分析工具返回的结果，决定任务是已经完成，还是需要继续执行下一步。</li></ul></li><li><strong>工具箱 (Toolbox)</strong>：Agent的“双手”，是它能与外部世界交互的手段。任何可以通过程序调用的功能都可以被封装成工具，例如： <ul><li>调用天气查询API</li><li>在数据库中执行SQL查询</li><li>发送邮件或消息</li><li>使用代码解释器进行科学计算</li><li>调用另一个Agent</li></ul></li><li><strong>记忆 (Memory)</strong>：Agent的“笔记本”，用于存储信息以供后续使用。 <ul><li><strong>短期记忆</strong>：存储当前的对话历史，保证交互的连贯性。</li><li><strong>长期记忆</strong>：通过外挂向量数据库（RAG）实现，让Agent拥有并能检索海量的私有领域知识。</li></ul></li></ul><p><strong>3. Agent的执行循环：ReAct框架</strong></p><p>为了让Agent能够有条不紊地执行任务，学术界和业界提出了经典的 <strong>ReAct (Reason + Act)</strong> 框架。这个框架将Agent的每一步行动都结构化为“思考 -&gt; 行动 -&gt; 观察”的循环：</p><ol><li><strong>Reason (思考)</strong>：LLM根据当前目标和历史信息，进行推理，生成“下一步我应该做什么”的思考过程。</li><li><strong>Act (行动)</strong>：LLM生成一个结构化的指令，通常是一个JSON对象，其中包含要调用的 <code>tool_name</code> 和需要传入的 <code>parameters</code>。这正是您理解的“状态码”或“动作指令”的具体体现。</li><li><strong>Observe (观察)</strong>：应用系统接收到这个指令，执行相应的工具调用，并将工具返回的结果（如API的响应、数据库的查询结果）作为新的信息。</li><li><strong>重复</strong>：将“观察”到的新信息补充给LLM，开始新一轮的“思考-行动”循环，直到任务完成。</li></ol><p><strong>4. 多Agent系统：构建大型LLM应用</strong></p><p>当单个Agent的能力不足以应对复杂业务时，就需要将多个Agent组合起来，形成一个多Agent系统。这是我理解的“大型LLM应用”的本质。</p><ul><li><strong>实现方式</strong>：将不同的业务能力封装成独立的、高内聚的Agent。例如，“订单查询Agent”、“库存管理Agent”、“客户沟通Agent”。</li><li><strong>组合架构</strong>： <ul><li><strong>主管-专员架构 (Orchestrator-Worker)</strong>：设立一个“总控Agent”（Orchestrator），它如同项目经理，负责任务的整体规划和调度，并将子任务分发给各个功能单一的“专员Agent”。这是目前最常用和最稳定的架构。</li><li><strong>协作架构 (Collaborative)</strong>：让多个Agent能够相互通信，协同解决问题。这更接近人类团队的工作模式，但实现起来也更复杂。</li></ul></li></ul><p><strong>5. 关键实现技术：Function Calling</strong></p><p>为了确保Agent“行动”（Act）的精确性和可靠性，我们需要强制LLM输出我们预定义的、严格的JSON结构。<strong>Function Calling</strong> 是实现这一目标的最佳技术。</p><ul><li>通过Function Calling，我们可以在调用LLM时，就将一份“可用工具清单”（包含每个工具的名称、功能描述、参数列表和格式）传递给它。</li><li>LLM在需要调用工具时，会生成一个完全符合我们预定义Schema的JSON对象，大大降低了解析错误的概率，使得整个Agent系统更加稳定和可靠。</li></ul><p>通过这套“Agent化”的思路，我们就能构建出真正能够深入业务、自动化执行复杂流程的强大AIGC应用。</p>",15)]))}const a=n(r,[["render",l]]),p=JSON.parse('{"path":"/AIGC%E5%BA%94%E7%94%A8%E5%B1%82%E5%BB%BA%E8%AE%BE%E6%80%9D%E8%B7%AF/%E4%B8%9A%E5%8A%A1%E6%B5%81%E7%A8%8B%E6%8E%A7%E5%88%B6-agent.html","title":"业务流程控制-agent","lang":"zh-CN","frontmatter":{"title":"业务流程控制-agent"},"git":{"createdTime":1753758135000,"updatedTime":1753758135000,"contributors":[{"name":"codingXuan","username":"codingXuan","email":"34129858+codingXuan@users.noreply.github.com","commits":1,"url":"https://github.com/codingXuan"}]},"readingTime":{"minutes":3.7,"words":1109},"filePathRelative":"AIGC应用层建设思路/业务流程控制-agent.md","excerpt":"<p><strong>1. 核心思想：从语言生成到任务执行</strong></p>\\n<p>传统的LLM应用以“问-答”为主，而Agent化的应用则将LLM从一个“语言模型”升级为了一个“任务执行大脑”。其核心思想是：利用LLM强大的自然语言理解和推理能力，将其作为中心控制器，通过生成结构化的指令来调用外部工具（API、数据库、代码等），从而完成复杂的、多步骤的业务流程。</p>\\n<p><strong>2. 单个Agent的内部构造 (The Anatomy of an Agent)</strong></p>\\n<p>一个功能完备的Agent，是“思考”与“行动”的结合体，其内部通常包含三大核心组件：</p>"}');export{a as comp,p as data};
