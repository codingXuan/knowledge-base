import{_ as s}from"./plugin-vue_export-helper-DlAUqK2U.js";import{c as e,a,o as t}from"./app-Cr2W10WY.js";const o={};function i(d,n){return t(),e("div",null,n[0]||(n[0]=[a(`<h4 id="_1-核心定位-连接数据源的-万能插头" tabindex="-1"><a class="header-anchor" href="#_1-核心定位-连接数据源的-万能插头"><span><strong>1. 核心定位：连接数据源的“万能插头”</strong></span></a></h4><p>Document Loaders (文档加载器) 是RAG流程的<strong>起点</strong>。它的核心职责是读取来自各种不同来源和格式的数据，并将其转换成一个标准化的、LangChain或LlamaIndex能够理解的 <code>Document</code> 对象。</p><p>一个 <code>Document</code> 对象通常包含两部分内容：</p><ul><li><code>**page_content**</code>: 文档的主要文本内容。</li><li><code>**metadata**</code>: 描述文档的元数据，例如来源文件名、页码、网址、作者等。</li></ul><h4 id="_2-loader-和-splitter-的核心区别" tabindex="-1"><a class="header-anchor" href="#_2-loader-和-splitter-的核心区别"><span><strong>2. Loader 和 Splitter 的核心区别</strong></span></a></h4><table><thead><tr><th>特性</th><th><strong>Document Loaders (文档加载器)</strong></th><th><strong>Text Splitters (文本分割器)</strong></th></tr></thead><tbody><tr><td><strong>核心职责</strong></td><td><strong>数据读取</strong>与<strong>格式解析</strong> (I/O &amp; Parsing)</td><td><strong>内容处理</strong>与<strong>文本切分</strong> (Processing &amp; Chunking)</td></tr><tr><td><strong>处理对象</strong></td><td>外部数据源 (文件, 网页, 数据库等)</td><td><code>Document</code><br> 对象的 <code>page_content</code></td></tr><tr><td><strong>输入</strong></td><td>文件路径, URL, API凭证等</td><td>一个或多个 <code>Document</code><br> 对象</td></tr><tr><td><strong>输出</strong></td><td>一个或多个标准化的 <code>Document</code><br> 对象</td><td>一系列更小的 <code>Document</code><br> 对象 (Chunks)</td></tr><tr><td><strong>工作流程</strong></td><td>RAG数据管道的<strong>第一步</strong></td><td>RAG数据管道的<strong>第二步</strong></td></tr></tbody></table><h4 id="_3-为什么需要五花八门的document-loaders" tabindex="-1"><a class="header-anchor" href="#_3-为什么需要五花八门的document-loaders"><span><strong>3. 为什么需要五花八门的Document Loaders？</strong></span></a></h4><p>因为现实世界的数据源是多种多样的。我们不可能用同一种方法来读取所有类型的数据。例如：</p><ul><li>读取一个 <code>.txt</code> 文件，只需要简单的文件I/O操作。</li><li>读取一个 <code>.pdf</code> 文件，需要专门的PDF解析库来提取文本和元数据。</li><li>读取一个网页，需要发起HTTP请求，并用HTML解析库（如Beautiful Soup）来提取正文内容。</li><li>读取一个Notion页面，需要调用Notion的官方API。</li></ul><p>LangChain和LlamaIndex的强大之处，就在于它们社区提供了<strong>数百种</strong>预置的Document Loaders，让开发者无需为每一种数据源都手动编写一套复杂的解析代码。</p><h4 id="_4-常见的document-loader类型-以langchain为例" tabindex="-1"><a class="header-anchor" href="#_4-常见的document-loader类型-以langchain为例"><span><strong>4. 常见的Document Loader类型（以LangChain为例）</strong></span></a></h4><ul><li><strong>文件加载器 (File Loaders)</strong><ul><li><code>TextLoader</code>: 加载 <code>.txt</code> 文件。</li><li><code>PyPDFLoader</code>: 加载 <code>.pdf</code> 文件，并将每一页作为一个<code>Document</code>对象。</li><li><code>CSVLoader</code>: 加载 <code>.csv</code> 文件，可将每一行或指定列作为<code>Document</code>。</li><li><code>JSONLoader</code>: 加载 <code>.json</code> 文件，并支持用 <a href="https://jsonpath.com/" target="_blank" rel="noopener noreferrer">JSONPath</a> 语法来抽取需要的内容。</li><li><code>UnstructuredLoader</code>: 一个“全能型”加载器，能处理包括Word(<code>.docx</code>), PowerPoint(<code>.pptx</code>), HTML, EML等多种复杂格式的文件。</li></ul></li><li><strong>网络加载器 (Web Loaders)</strong><ul><li><code>WebBaseLoader</code>: 加载单个网页。</li><li><code>RecursiveUrlLoader</code>: 可以递归地爬取一个网站下的所有链接页面。</li></ul></li><li><strong>集成加载器 (Integration Loaders)</strong><ul><li><code>NotionDirectoryLoader</code>: 加载整个Notion数据库或页面。</li><li><code>SlackLoader</code>: 加载Slack频道中的聊天记录。</li><li><code>WikipediaLoader</code>: 直接从维基百科加载词条。</li></ul></li></ul><h4 id="_5-实践示例-loader与splitter的协同工作" tabindex="-1"><a class="header-anchor" href="#_5-实践示例-loader与splitter的协同工作"><span><strong>5. 实践示例：Loader与Splitter的协同工作</strong></span></a></h4><p>下面的代码展示了“先加载，后切分”的完整流程。</p><p>Python</p><div class="language-plain line-numbers-mode" data-highlighter="shiki" data-ext="plain" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code class="language-plain"><span class="line"><span>from langchain_community.document_loaders import PyPDFLoader</span></span>
<span class="line"><span>from langchain.text_splitter import RecursiveCharacterTextSplitter</span></span>
<span class="line"><span></span></span>
<span class="line"><span># --- 第 1 步: 使用Document Loader加载数据 ---</span></span>
<span class="line"><span># 实例化一个PDF加载器，指向您的PDF文件</span></span>
<span class="line"><span>loader = PyPDFLoader(&quot;example_document.pdf&quot;)</span></span>
<span class="line"><span></span></span>
<span class="line"><span># 调用load()方法，将PDF的每一页加载成一个Document对象</span></span>
<span class="line"><span># 假设PDF有3页，那么 docs 就是一个包含3个Document对象的列表</span></span>
<span class="line"><span>docs = loader.load()</span></span>
<span class="line"><span></span></span>
<span class="line"><span>print(f&quot;文档加载完成，共加载了 {len(docs)} 页。&quot;)</span></span>
<span class="line"><span>print(&quot;--- 原始Document内容示例 (第一页) ---&quot;)</span></span>
<span class="line"><span>print(docs[0].page_content[:300]) # 打印第一页的前300个字符</span></span>
<span class="line"><span>print(f&quot;元数据: {docs[0].metadata}&quot;)</span></span>
<span class="line"><span>print(&quot;\\n&quot; + &quot;=&quot;*50 + &quot;\\n&quot;)</span></span>
<span class="line"><span></span></span>
<span class="line"><span></span></span>
<span class="line"><span># --- 第 2 步: 使用Text Splitter切分加载好的文档 ---</span></span>
<span class="line"><span># 实例化一个文本分割器</span></span>
<span class="line"><span>text_splitter = RecursiveCharacterTextSplitter(</span></span>
<span class="line"><span>    chunk_size=500,</span></span>
<span class="line"><span>    chunk_overlap=50</span></span>
<span class="line"><span>)</span></span>
<span class="line"><span></span></span>
<span class="line"><span># 调用split_documents()方法，将所有加载的Document对象进行切分</span></span>
<span class="line"><span># 3页的文档可能会被切分成几十个更小的块(Chunks)</span></span>
<span class="line"><span>chunks = text_splitter.split_documents(docs)</span></span>
<span class="line"><span></span></span>
<span class="line"><span>print(f&quot;文本切分完成，共得到 {len(chunks)} 个文本块 (Chunks)。&quot;)</span></span>
<span class="line"><span>print(&quot;--- 切分后的Chunk内容示例 (第一个Chunk) ---&quot;)</span></span>
<span class="line"><span>print(chunks[0].page_content)</span></span>
<span class="line"><span>print(f&quot;Chunk的元数据 (继承自原始页): {chunks[0].metadata}&quot;)</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><strong>总结</strong>：Document Loader是RAG系统与多样化数据世界之间的桥梁。它负责**“标准化”<strong>，将任何来源的数据都转换成统一的</strong><code>**Document**</code><strong>格式，为后续的</strong>“精细化”**处理（由Text Splitter完成）铺平道路。选择合适的Loader，是构建高效、健壮RAG数据管道的第一步。</p>`,17)]))}const c=s(o,[["render",i]]),p=JSON.parse('{"path":"/tech/AIGC%E6%A1%86%E6%9E%B6%E8%AF%A6%E8%A7%A3/RAG%E6%A0%B8%E5%BF%83%E7%BB%84%E4%BB%B6/%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86%E4%B8%8E%E5%88%87%E5%88%86/%E6%96%87%E6%A1%A3%E5%8A%A0%E8%BD%BD%E5%99%A8-Document%20Loaders.html","title":"文档加载器","lang":"zh-CN","frontmatter":{"title":"文档加载器","date":"2025-04-12T00:00:00.000Z"},"git":{"createdTime":1753758135000,"updatedTime":1753843586000,"contributors":[{"name":"codingXuan","username":"codingXuan","email":"34129858+codingXuan@users.noreply.github.com","commits":3,"url":"https://github.com/codingXuan"}]},"readingTime":{"minutes":3.46,"words":1037},"filePathRelative":"tech/AIGC框架详解/RAG核心组件/数据处理与切分/文档加载器-Document Loaders.md","excerpt":"<h4><strong>1. 核心定位：连接数据源的“万能插头”</strong></h4>\\n<p>Document Loaders (文档加载器) 是RAG流程的<strong>起点</strong>。它的核心职责是读取来自各种不同来源和格式的数据，并将其转换成一个标准化的、LangChain或LlamaIndex能够理解的 <code>Document</code> 对象。</p>\\n<p>一个 <code>Document</code> 对象通常包含两部分内容：</p>\\n<ul>\\n<li><code>**page_content**</code>: 文档的主要文本内容。</li>\\n<li><code>**metadata**</code>: 描述文档的元数据，例如来源文件名、页码、网址、作者等。</li>\\n</ul>"}');export{c as comp,p as data};
