---
title: 业务流程控制-agent
date: 2024-07-10 
---

**1. 核心思想：从语言生成到任务执行**

传统的LLM应用以“问-答”为主，而Agent化的应用则将LLM从一个“语言模型”升级为了一个“任务执行大脑”。其核心思想是：利用LLM强大的自然语言理解和推理能力，将其作为中心控制器，通过生成结构化的指令来调用外部工具（API、数据库、代码等），从而完成复杂的、多步骤的业务流程。

**2. 单个Agent的内部构造 (The Anatomy of an Agent)**

一个功能完备的Agent，是“思考”与“行动”的结合体，其内部通常包含三大核心组件：

+ **规划器 (Planner)**：Agent的大脑，由LLM担当。它负责：
    - **任务理解与拆解**：将用户的模糊指令拆解成一系列清晰、可执行的步骤。
    - **工具选择**：根据当前步骤，从一系列可用工具中选择最合适的一个。
    - **推理与决策**：分析工具返回的结果，决定任务是已经完成，还是需要继续执行下一步。
+ **工具箱 (Toolbox)**：Agent的“双手”，是它能与外部世界交互的手段。任何可以通过程序调用的功能都可以被封装成工具，例如：
    - 调用天气查询API
    - 在数据库中执行SQL查询
    - 发送邮件或消息
    - 使用代码解释器进行科学计算
    - 调用另一个Agent
+ **记忆 (Memory)**：Agent的“笔记本”，用于存储信息以供后续使用。
    - **短期记忆**：存储当前的对话历史，保证交互的连贯性。
    - **长期记忆**：通过外挂向量数据库（RAG）实现，让Agent拥有并能检索海量的私有领域知识。

**3. Agent的执行循环：ReAct框架**

为了让Agent能够有条不紊地执行任务，学术界和业界提出了经典的 **ReAct (Reason + Act)** 框架。这个框架将Agent的每一步行动都结构化为“思考 -> 行动 -> 观察”的循环：

1. **Reason (思考)**：LLM根据当前目标和历史信息，进行推理，生成“下一步我应该做什么”的思考过程。
2. **Act (行动)**：LLM生成一个结构化的指令，通常是一个JSON对象，其中包含要调用的 `tool_name` 和需要传入的 `parameters`。这正是您理解的“状态码”或“动作指令”的具体体现。
3. **Observe (观察)**：应用系统接收到这个指令，执行相应的工具调用，并将工具返回的结果（如API的响应、数据库的查询结果）作为新的信息。
4. **重复**：将“观察”到的新信息补充给LLM，开始新一轮的“思考-行动”循环，直到任务完成。

**4. 多Agent系统：构建大型LLM应用**

当单个Agent的能力不足以应对复杂业务时，就需要将多个Agent组合起来，形成一个多Agent系统。这是我理解的“大型LLM应用”的本质。

+ **实现方式**：将不同的业务能力封装成独立的、高内聚的Agent。例如，“订单查询Agent”、“库存管理Agent”、“客户沟通Agent”。
+ **组合架构**：
    - **主管-专员架构 (Orchestrator-Worker)**：设立一个“总控Agent”（Orchestrator），它如同项目经理，负责任务的整体规划和调度，并将子任务分发给各个功能单一的“专员Agent”。这是目前最常用和最稳定的架构。
    - **协作架构 (Collaborative)**：让多个Agent能够相互通信，协同解决问题。这更接近人类团队的工作模式，但实现起来也更复杂。

**5. 关键实现技术：Function Calling**

为了确保Agent“行动”（Act）的精确性和可靠性，我们需要强制LLM输出我们预定义的、严格的JSON结构。**Function Calling** 是实现这一目标的最佳技术。

+ 通过Function Calling，我们可以在调用LLM时，就将一份“可用工具清单”（包含每个工具的名称、功能描述、参数列表和格式）传递给它。
+ LLM在需要调用工具时，会生成一个完全符合我们预定义Schema的JSON对象，大大降低了解析错误的概率，使得整个Agent系统更加稳定和可靠。

通过这套“Agent化”的思路，我们就能构建出真正能够深入业务、自动化执行复杂流程的强大AIGC应用。

